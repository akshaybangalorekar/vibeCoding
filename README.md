# vibeCoding

Code Explanation and Structure
This is a Spring Boot 3.2.0 application built with Java 17 and Maven. It's a fraud detection service that evaluates financial transactions against configurable rules using Spring Expression Language (SpEL). The app uses an in-memory H2 database, OAuth2 JWT authentication, and SSL. Below, I'll explain the structure, key components, and how to run it.

Project Structure
The project follows standard Maven and Spring Boot conventions:

pom.xml: Maven configuration file defining dependencies, Java version (17), and Spring Boot parent (3.2.0). Key dependencies include:

spring-boot-starter-web: For REST APIs.
spring-boot-starter-security and spring-boot-starter-oauth2-resource-server: For JWT-based authentication.
spring-boot-starter-data-jpa and h2: For JPA persistence with an in-memory H2 database.
spring-boot-starter-validation: For input validation.
spring-boot-starter-test: For unit tests.
Why these? Spring Boot starters provide auto-configuration, reducing boilerplate. H2 is used for simplicity in demos (no external DB needed). OAuth2 enables secure API access.
example: Main source code.

VibeCodingApplication.java: Entry point with @SpringBootApplication (enables auto-config, component scanning, and property support).
config/: Configuration classes.
SecurityConfig.java: Configures Spring Security with OAuth2 JWT. /api/fraud/check is public for demo purposes; others require authentication. Uses @EnableMethodSecurity for role-based access (e.g., @PreAuthorize("hasRole('ADMIN')")).
CustomJwtAuthenticationConverter.java: Extracts roles from JWT claims (e.g., from Keycloak's realm_access.roles) and prefixes them with ROLE_ for Spring Security.
DataLoader.java: Implements CommandLineRunner to seed the DB with default rules on startup if empty. Ensures the app has rules to evaluate immediately.
controller/: REST endpoints.
FraudController.java: Exposes APIs for fraud checks and rule management. Uses @RestController and @RequestMapping("/api/fraud"). Endpoints include:
POST /check: Evaluates a transaction (public).
GET /rules: Lists rules (admin only).
POST /rules: Adds a rule (admin only).
DELETE /rules/{id}: Deletes a rule (admin only).
Why? Separates concerns; controller handles HTTP requests/responses, delegating logic to services.
model/: JPA entities.
Rule.java: Represents a fraud rule with name, expression (SpEL string), and action (e.g., "BLOCK"). Uses @Entity for DB mapping.
Transaction.java: Represents a transaction with fields like userId, amount, location, timestamp, and transactionCount (for velocity checks). BigDecimal for precise money handling.
Why entities? Enables persistence and querying via JPA repositories.
repository/: Data access.
RuleRepository.java and TransactionRepository.java: Extend JpaRepository for CRUD operations. No custom methods needed here.
Why? Spring Data JPA auto-generates queries, simplifying DB interactions.
service/: Business logic.
FraudDetectionService.java: Core logic. Evaluates transactions against DB rules using SpEL (e.g., amount > 10000). Falls back to hardcoded/config rules if DB is empty. Returns actions like "ALLOW", "BLOCK", "FLAG", or "REVIEW".
Why SpEL? Allows dynamic, configurable rules without recompiling code. Secure as it's evaluated in a controlled context.
application.properties: Configuration.

Sets server port to 8443 with SSL (using a keystore).
Configures OAuth2 issuer URI (placeholder: https://example.com).
H2 DB settings (in-memory, console enabled for debugging).
Configurable fraud rules as properties (mirrors DataLoader defaults).
Why? Externalizes config for different environments (e.g., prod vs. dev).
VibeCodingApplicationTests.java: Basic Spring Boot test to verify context loads.

target: Build output (generated by Maven).

README.md: Minimal documentation.

Key Design Decisions and Reasons
Spring Boot: Simplifies setup with auto-configuration, starters, and embedded server (Tomcat). Version 3.2.0 uses Jakarta EE (not javax) for compatibility with modern Java.
JPA + H2: In-memory DB for quick demos; easily switchable to PostgreSQL/MySQL in prod. Entities use @GeneratedValue for auto IDs.
Security: OAuth2 JWT for stateless auth. Custom converter handles role extraction. /check is public to allow easy testing, but real apps should secure it.
SpEL for Rules: Flexible and powerful for expressions (e.g., amount > 10000). Parsed at runtime, allowing admins to add rules via API without redeploying.
Fallback Rules: If DB is empty, uses config-based rules. Ensures the service always works.
SSL: Runs on HTTPS (port 8443) for security, using a self-signed keystore (change keystore.p12 for prod).
Validation: Starter included but not heavily used here; could add @Valid to controllers for input checks.
Tests: Minimal; in a real app, add unit tests for service logic and integration tests for APIs.
How to Run the Application
Prerequisites: Java 17+ and Maven installed. The project uses H2 (no external DB needed).

Build the Project:

Run mvn clean install (already done, as per context; exit code 0 means success). This compiles code, runs tests, and packages into a JAR.
Run the Application:

Via Maven: mvn spring-boot:run (starts on port 8443 with SSL).
Via JAR: java -jar target/vibeCoding-0.0.1-SNAPSHOT.jar (after build).
The app starts with default rules loaded.
Access the App:

H2 Console: Visit http://localhost:8443/h2-console (JDBC URL: jdbc:h2:mem:testdb, user: sa, password: empty). View DB tables.
APIs (use tools like Postman or curl; ignore SSL warnings for self-signed cert):
Check transaction: POST https://localhost:8443/api/fraud/check with JSON body like {"userId":"user1", "amount":15000, "location":"NY", "timestamp":"2023-10-01T10:00:00", "transactionCount":3}. Returns "BLOCK" for high amounts.
Get rules: GET https://localhost:8443/api/fraud/rules (needs JWT token with admin role).
For JWT auth, set up an OAuth2 provider (e.g., Keycloak) and update issuer-uri in properties.
Stop: Ctrl+C in terminal.

Testing: Run mvn test for unit tests.

This setup is production-ready with minor tweaks (e.g., real DB, keystore). For learning, experiment with adding rules or modifying SpEL expressions! If you need help with specific parts, let me know.
